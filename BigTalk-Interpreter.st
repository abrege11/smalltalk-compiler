Object subclass: #BigTalkInterpreter	instanceVariableNames: 'env program'	classVariableNames: ''	poolDictionaries: ''	category: 'BigTalk-Interpreter'!!BigTalkInterpreter methodsFor: 'initialize-release' stamp: 'jws 11/20/2024 11:31'!initialize	super initialize.	env := BTEnvironment new.! !!BigTalkInterpreter methodsFor: 'accessing' stamp: 'jws 11/21/2024 21:51'!program	^program! !!BigTalkInterpreter methodsFor: 'accessing' stamp: 'jws 11/21/2024 21:51'!program: aString	program := aString! !!BigTalkInterpreter methodsFor: 'visiting' stamp: 'jws 11/21/2024 11:29'!visitBTArgumentList: aBTArgumentList 		^aBTArgumentList arguments		collect: [:each | each accept: self]! !!BigTalkInterpreter methodsFor: 'visiting' stamp: 'jws 11/21/2024 11:47'!visitBTArithmeticOperator: aBTArithmeticOperator 		| opSelector |	opSelector := aBTArithmeticOperator opSymbol.	opSelector = #/ ifTrue: [opSelector := #//].	opSelector = #MOD ifTrue: [opSelector := #\\].	^opSelector asSymbol! !!BigTalkInterpreter methodsFor: 'visiting' stamp: 'jws 11/21/2024 11:18'!visitBTAssignmentStatement: aBTAssignmentStatement 		| var value |	var := env variable: aBTAssignmentStatement variableId.	value := aBTAssignmentStatement expression accept: self.	var set: value.! !!BigTalkInterpreter methodsFor: 'visiting' stamp: 'jws 11/21/2024 11:44'!visitBTBinaryExpression: aBTBinaryExpression 		| arg1 arg2 opSelector |	arg1 := aBTBinaryExpression arg1 accept: self.	arg2 := aBTBinaryExpression arg2 accept: self.	opSelector := aBTBinaryExpression operator accept: self.	^arg1 perform: opSelector with: arg2.! !!BigTalkInterpreter methodsFor: 'visiting' stamp: 'jws 11/20/2024 20:12'!visitBTCompoundStatement: aBTCompoundStatement 		aBTCompoundStatement statements		do: [:each | each accept: self]! !!BigTalkInterpreter methodsFor: 'visiting' stamp: 'jws 11/21/2024 11:14'!visitBTFunction: aBTFunction 		env		declare: aBTFunction identifier		method: aBTFunction! !!BigTalkInterpreter methodsFor: 'visiting' stamp: 'jws 11/21/2024 11:47'!visitBTFunctionCall: aBTFunctionCall 		| funcName func args params result |	funcName := aBTFunctionCall identifier.	func := env method: funcName.	args := aBTFunctionCall arguments accept: self.	env activate.	params := func parameters accept: self.	self apply: args to: params.	env declare: funcName variable: (BTVariable type: func returnType).	func methodBody accept: self.	result := env variable: funcName.	env deactivate.	^result get! !!BigTalkInterpreter methodsFor: 'visiting' stamp: 'jws 11/21/2024 07:18'!visitBTIfThenElseStatement: aBTIfThenElseStatement 		(aBTIfThenElseStatement expression accept: self)		ifTrue: [aBTIfThenElseStatement trueStatement accept: self]		ifFalse: [aBTIfThenElseStatement falseStatement accept: self]! !!BigTalkInterpreter methodsFor: 'visiting' stamp: 'jws 11/21/2024 07:17'!visitBTMethodBody: aBTMethodBody 	aBTMethodBody variables accept: self.	aBTMethodBody statement accept: self.! !!BigTalkInterpreter methodsFor: 'visiting' stamp: 'jws 11/20/2024 11:38'!visitBTMethods: aBTMethods 	aBTMethods declarations		do: [:each | each accept: self]! !!BigTalkInterpreter methodsFor: 'visiting' stamp: 'jws 11/21/2024 11:32'!visitBTParameterList: aBTParameterList 		^aBTParameterList parameters		collect: [:each | each accept: self]! !!BigTalkInterpreter methodsFor: 'visiting' stamp: 'jws 11/20/2024 11:37'!visitBTProgram: aBTProgram 	aBTProgram variables accept: self.	aBTProgram methods accept: self.	aBTProgram statement accept: self.! !!BigTalkInterpreter methodsFor: 'visiting' stamp: 'jws 11/21/2024 07:22'!visitBTRelationalOperator: aBTRelationalOperator 		^aBTRelationalOperator opSymbol! !!BigTalkInterpreter methodsFor: 'visiting' stamp: 'ab 12/2/2024 15:32'!visitBTVariableDeclaration: aBTVariableDeclaration 	| var |	var := BTVariable type: aBTVariableDeclaration type.	[env 		declare: aBTVariableDeclaration name 		variable: var]			on: BTError			do: [:ex | self showError: ex astNode: aBTVariableDeclaration].	^var	! !!BigTalkInterpreter methodsFor: 'visiting' stamp: 'jws 11/21/2024 11:21'!visitBTVariableReference: aBTVariableReference 		^(env variable: aBTVariableReference identifier) get! !!BigTalkInterpreter methodsFor: 'visiting' stamp: 'jws 11/20/2024 11:38'!visitBTVariables: aBTVariables 		aBTVariables declarations		do: [:each | each accept: self]! !!BigTalkInterpreter methodsFor: 'visiting' stamp: 'jws 11/21/2024 07:28'!visitBTWriteLine: aBTWriteLine 		Transcript cr! !!BigTalkInterpreter methodsFor: 'visiting' stamp: 'jws 11/21/2024 21:53'!visitBTliteralBoolean: aBTliteralBoolean 		^aBTliteralBoolean value! !!BigTalkInterpreter methodsFor: 'visiting' stamp: 'jws 11/21/2024 07:06'!visitBTliteralInteger: aBTliteralInteger 		^aBTliteralInteger value! !!BigTalkInterpreter methodsFor: 'visiting' stamp: 'jws 11/20/2024 11:40'!visitBTliteralString: aBTliteralString 		^aBTliteralString value! !!BigTalkInterpreter methodsFor: 'visiting' stamp: 'jws 11/21/2024 21:53'!visitWriteBoolean: aBTWriteBoolean 		Transcript show: (aBTWriteBoolean expression accept: self) printString! !!BigTalkInterpreter methodsFor: 'visiting' stamp: 'jws 11/21/2024 11:22'!visitWriteInteger: aBTWriteInteger 		Transcript show: (aBTWriteInteger expression accept: self)! !!BigTalkInterpreter methodsFor: 'visiting' stamp: 'jws 11/20/2024 11:39'!visitWriteString: aBTWriteString 		Transcript show: (aBTWriteString expression accept: self)! !!BigTalkInterpreter methodsFor: 'utility' stamp: 'jws 11/21/2024 11:40'!apply: args to: params 		| argStream paramStream |	argStream := ReadStream on: args.	paramStream := ReadStream on: params.	[argStream atEnd]		whileFalse:			[paramStream next set: argStream next].	! !!BigTalkInterpreter methodsFor: 'utility' stamp: 'jws 11/21/2024 21:46'!errorTextFor: anAst	| errorText |	errorText := self program asText.	errorText		addAttribute: TextColor red		from: anAst range first		to: anAst range last.	^errorText! !!BigTalkInterpreter methodsFor: 'utility' stamp: 'jws 11/21/2024 21:46'!showError: anExceptionastNode: anAstNode	StringHolder new		textContents: (self errorTextFor: anAstNode);		openLabel: anException class name! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BigTalkInterpreter class	instanceVariableNames: ''!!BigTalkInterpreter class methodsFor: 'interpreting' stamp: 'jws 11/21/2024 21:51'!interpret: aProgramString	| ast interpreter |	ast := BigTalkParser parse: aProgramString.	interpreter := self new.	interpreter program: aProgramString.	ast accept: interpreter.! !TestCase subclass: #BigTalkInterpreterTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'BigTalk-Interpreter'!!BigTalkInterpreterTestCase methodsFor: 'running' stamp: 'jws 11/21/2024 21:48'!testInterpretBadVariablesProgram	| formattedCode |	formattedCode := BigTalkInterpreter interpret: self badVariablesProgram.! !!BigTalkInterpreterTestCase methodsFor: 'running' stamp: 'jws 11/20/2024 11:44'!testInterpretFactorialProgram	| formattedCode |	formattedCode := BigTalkInterpreter interpret: self factorialProgram.! !!BigTalkInterpreterTestCase methodsFor: 'running' stamp: 'jws 11/20/2024 11:43'!testInterpretNanoProgram	| formattedCode |	formattedCode := BigTalkInterpreter interpret: self nanoProgram.! !!BigTalkInterpreterTestCase methodsFor: 'accessing' stamp: 'jws 11/21/2024 21:48'!badVariablesProgram	^'program	variables		answer : integer		msg : string		answer : string		isIt : boolean	do		[answer <- 42		writeInteger answer		writeLine		msg <- "Hello, World!!"		writeString msg		writeLine		isIt <- true		writeBoolean isIt		writeLine]'! !!BigTalkInterpreterTestCase methodsFor: 'accessing' stamp: 'jws 11/21/2024 11:51'!factorialProgram	^'program	variables		msg : string	methods		function factorial(n:integer) : integer		do			if n = 0 then				factorial <- 1			else				factorial <- n * factorial( n - 1 )	do		[msg <- "Factorial 5 is "		writeString msg		writeInteger factorial(5)		writeLine]'! !!BigTalkInterpreterTestCase methodsFor: 'accessing' stamp: 'jws 11/20/2024 11:40'!nanoProgram	^'program do writeString "Hello, Class!!"'! !